# Common configuration settings shared across all machines

# Data paths
data:
  base_dir: "../../200_datasets_enhanced"
  dataset_file: "11_final_enhanced_java.json"

# Output configuration
output:
  result_dir: "../02_initial_results"
  log_dir: "./00_logs"  # Local to the source code folder

# Logging configuration
logging:
  # Separate log files for different log levels
  errors_only: true  # Only store errors and warnings in a file, not info logs
  error_log_file: "errors.log"  # File for storing errors and warnings

# Ollama API options (common across all models)
# These settings are consistent across all machines and models
ollama_options:
  # Core generation parameters
  temperature: 0.5    # Controls randomness (0.0-1.0, lower = more deterministic)
  seed: 42            # Random seed for reproducibility
  num_predict: 20480   # Maximum number of tokens to generate
  top_k: 40           # Limits token selection to top K most likely tokens
  top_p: 0.5          # Nucleus sampling (consider tokens comprising top p% of probability mass)

  # Mirostat sampling algorithm parameters (adaptive control for perplexity)
  mirostat: 0           # 0 = disabled, 1 = Mirostat, 2 = Mirostat 2.0
  mirostat_eta: 0.1     # Learning rate for Mirostat algorithm
  mirostat_tau: 3.0     # Target entropy for Mirostat algorithm

  # Model-specific parameters
  num_gqa: 8            # Number of group-query attention heads

  # Repetition control
  repeat_last_n: -1     # Consider last N tokens for repetition penalty (-1 = all)
  repeat_penalty: 1.5   # Penalty for repeating tokens (1.0 = no penalty)

  # Additional sampling parameters
  tfs_z: 1.0            # Tail free sampling parameter

# System prompt used for all models
system_prompt: |
  Role: Expert Code Security Analyst

  Your task is to carefully examine the provided Java source code along with its associated Abstract Syntax Tree (AST) information. Always use the provided AST metadata to assist you in determining the presence of security vulnerabilities and to precisely localize vulnerabilities at the function level.

  Steps to follow:

  Step 1: Initial Security Assessment
  - Thoroughly review both the provided source code and its AST metadata, including package declarations, import statements, class definitions, inheritance relationships, method signatures, field declarations, and interfaces.
  - Utilize insights derived from the AST metadata to determine if the code contains any vulnerabilities.
  - Clearly state your initial findings. If no vulnerabilities exist, explicitly state:
    "No vulnerabilities were identified in the provided code."

  Step 2: Function-Level Vulnerability Analysis (Only if vulnerabilities are found)
  - Identify and analyze each vulnerable function carefully, leveraging AST details to provide clarity and precision in your analysis.
  - For every vulnerable function identified, clearly provide:
    - Function Signature: Clearly presented as functionName(type1 arg1, type2 arg2).
    - Reason: Provide a concise, detailed explanation explicitly referencing relevant AST elements (such as method visibility modifiers, parameter types, class inheritance structures, imports, or field declarations) that directly or indirectly contribute to the identified security vulnerability.

  Output:
  Present your findings clearly and understandably. Structured formatting is not required; however, your explanation must explicitly reference AST-derived information to ensure the reasoning behind any vulnerability assessment is clearly communicated.